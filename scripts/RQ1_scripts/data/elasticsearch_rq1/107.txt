{"randomdocline":"Indexing operations which entail mapping changes require a blocking request to the master node to update the mapping.","signature":"public void testMasterFailoverDuringIndexingWithMappingChanges() throws Throwable","doc":"Indexing operations which entail mapping changes require a blocking request to the master node to update the mapping.\r\nIf the master node is being disrupted or if it cannot commit cluster state changes, it needs to retry within timeout limits.\r\nThis retry logic is implemented in TransportMasterNodeAction and tested by the following master failover scenario.\r\n","source":"{\r\n    logger.info(\"--> start 4 nodes, 3 master, 1 data\");\r\n    final Settings sharedSettings = Settings.builder().put(\"cluster.join.timeout\", \/\/ still long to induce failures but not too long so test won't time out\r\n    \"10s\").build();\r\n    internalCluster().setBootstrapMasterNodeIndex(2);\r\n    internalCluster().startMasterOnlyNodes(3, sharedSettings);\r\n    String dataNode = internalCluster().startDataOnlyNode(sharedSettings);\r\n    logger.info(\"--> wait for all nodes to join the cluster\");\r\n    ensureStableCluster(4);\r\n    \/\/ We index data with mapping changes into cluster and have master failover at same time\r\n    client().admin().indices().prepareCreate(\"myindex\").setSettings(Settings.builder().put(\"index.number_of_shards\", 1).put(\"index.number_of_replicas\", 0)).get();\r\n    ensureGreen(\"myindex\");\r\n    final CyclicBarrier barrier = new CyclicBarrier(2);\r\n    Thread indexingThread = new Thread(new Runnable() {\r\n\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                barrier.await();\r\n            } catch (InterruptedException e) {\r\n                logger.warn(\"Barrier interrupted\", e);\r\n                return;\r\n            } catch (BrokenBarrierException e) {\r\n                logger.warn(\"Broken barrier\", e);\r\n                return;\r\n            }\r\n            for (int i = 0; i < 10; i++) {\r\n                \/\/ index data with mapping changes\r\n                IndexResponse response = client(dataNode).prepareIndex(\"myindex\").setSource(\"field_\" + i, \"val\").get();\r\n                assertEquals(DocWriteResponse.Result.CREATED, response.getResult());\r\n            }\r\n        }\r\n    });\r\n    indexingThread.setName(\"indexingThread\");\r\n    indexingThread.start();\r\n    barrier.await();\r\n    \/\/ interrupt communication between master and other nodes in cluster\r\n    String master = internalCluster().getMasterName();\r\n    Set<String> otherNodes = new HashSet<>(Arrays.asList(internalCluster().getNodeNames()));\r\n    otherNodes.remove(master);\r\n    NetworkDisruption partition = new NetworkDisruption(new TwoPartitions(Collections.singleton(master), otherNodes), new NetworkDisconnect());\r\n    internalCluster().setDisruptionScheme(partition);\r\n    logger.info(\"--> disrupting network\");\r\n    partition.startDisrupting();\r\n    logger.info(\"--> waiting for new master to be elected\");\r\n    ensureStableCluster(3, dataNode);\r\n    partition.stopDisrupting();\r\n    logger.info(\"--> waiting to heal\");\r\n    ensureStableCluster(4);\r\n    indexingThread.join();\r\n    ensureGreen(\"myindex\");\r\n    refresh();\r\n    assertThat(client().prepareSearch(\"myindex\").get().getHits().getTotalHits().value, equalTo(10L));\r\n}","pathname":"D:\\Documents\\PA_Research\\DocModularity_Study\\elasticsearch\\server\/src\/internalClusterTest\/java\/org\/elasticsearch\/action\/support\/master\/IndexingMasterFailoverIT.java"}