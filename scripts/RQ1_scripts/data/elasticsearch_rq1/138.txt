{"randomdocline":"Lookup offsets for a provided zone. This <strong>can<\/strong> fail if","signature":"public static Lookup lookup(ZoneId zone, long minUtcMillis, long maxUtcMillis)","doc":"Lookup offsets for a provided zone. This <strong>can<\/strong> fail if\r\nthere are many transitions and the provided lookup would be very large.\r\n\r\n@return a {@linkplain Lookup} or {@code null} if none could be built\r\n","source":"{\r\n    if (minUtcMillis > maxUtcMillis) {\r\n        throw new IllegalArgumentException(\"[\" + minUtcMillis + \"] must be <= [\" + maxUtcMillis + \"]\");\r\n    }\r\n    ZoneRules rules = zone.getRules();\r\n    {\r\n        LocalTimeOffset fixed = checkForFixedZone(zone, rules);\r\n        if (fixed != null) {\r\n            return new FixedLookup(zone, fixed);\r\n        }\r\n    }\r\n    List<ZoneOffsetTransition> transitions = collectTransitions(zone, rules, minUtcMillis, maxUtcMillis);\r\n    if (transitions == null) {\r\n        \/\/ The range is too large for us to pre-build all the offsets\r\n        return null;\r\n    }\r\n    if (transitions.size() < 3) {\r\n        \/*\r\n             * Its actually quite common that there are *very* few transitions.\r\n             * This case where there are only two transitions covers an entire\r\n             * year of data! In any case, it is slightly faster to do the\r\n             * \"simpler\" thing and compare the start times instead of perform\r\n             * a binary search when there are so few offsets to look at.\r\n             *\/\r\n        return new LinkedListLookup(zone, minUtcMillis, maxUtcMillis, transitions);\r\n    }\r\n    return new TransitionArrayLookup(zone, minUtcMillis, maxUtcMillis, transitions);\r\n}","pathname":"D:\\Documents\\PA_Research\\DocModularity_Study\\elasticsearch\\server\/src\/main\/java\/org\/elasticsearch\/common\/LocalTimeOffset.java"}