{"randomdocline":"non-{@link BucketCollector#NO_OP_COLLECTOR} collectors.","signature":"public static BucketCollector wrap(Iterable<? extends BucketCollector> collectors)","doc":"Wraps a list of {@link BucketCollector}s with a {@link MultiBucketCollector}. This\r\nmethod works as follows:\r\n<ul>\r\n<li>Filters out the {@link BucketCollector#NO_OP_COLLECTOR}s collectors, so they are not used\r\nduring search time.\r\n<li>If the input contains 1 real collector, it is returned.\r\n<li>Otherwise the method returns a {@link MultiBucketCollector} which wraps the\r\nnon-{@link BucketCollector#NO_OP_COLLECTOR} collectors.\r\n<\/ul>\r\n","source":"{\r\n    \/\/ For the user's convenience, we allow NO_OP collectors to be passed.\r\n    \/\/ However, to improve performance, these null collectors are found\r\n    \/\/ and dropped from the array we save for actual collection time.\r\n    int n = 0;\r\n    for (BucketCollector c : collectors) {\r\n        if (c != NO_OP_COLLECTOR) {\r\n            n++;\r\n        }\r\n    }\r\n    if (n == 0) {\r\n        return NO_OP_COLLECTOR;\r\n    } else if (n == 1) {\r\n        \/\/ only 1 Collector - return it.\r\n        BucketCollector col = null;\r\n        for (BucketCollector c : collectors) {\r\n            if (c != null) {\r\n                col = c;\r\n                break;\r\n            }\r\n        }\r\n        return col;\r\n    } else {\r\n        BucketCollector[] colls = new BucketCollector[n];\r\n        n = 0;\r\n        for (BucketCollector c : collectors) {\r\n            if (c != null) {\r\n                colls[n++] = c;\r\n            }\r\n        }\r\n        return new MultiBucketCollector(colls);\r\n    }\r\n}","pathname":"D:\\Documents\\PA_Research\\DocModularity_Study\\elasticsearch\\server\/src\/main\/java\/org\/elasticsearch\/search\/aggregations\/MultiBucketCollector.java"}