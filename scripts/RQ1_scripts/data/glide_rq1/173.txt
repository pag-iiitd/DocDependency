{"randomdocline":"@return the maximum number of processors available to the VM; never smaller than one","signature":"private static int getCoreCountPre17()","doc":"Determines the number of cores available on the device (pre-v17).\r\n\r\n<p>Before Jellybean, {@link Runtime#availableProcessors()} returned the number of awake cores,\r\nwhich may not be the number of available cores depending on the device's current state. See\r\nhttps:\/\/stackoverflow.com\/a\/30150409.\r\n\r\n@return the maximum number of processors available to the VM; never smaller than one\r\n","source":"{\r\n    \/\/ We override the current ThreadPolicy to allow disk reads.\r\n    \/\/ This shouldn't actually do disk-IO and accesses a device file.\r\n    \/\/ See: https:\/\/github.com\/bumptech\/glide\/issues\/1170\r\n    File[] cpus = null;\r\n    ThreadPolicy originalPolicy = StrictMode.allowThreadDiskReads();\r\n    try {\r\n        File cpuInfo = new File(CPU_LOCATION);\r\n        final Pattern cpuNamePattern = Pattern.compile(CPU_NAME_REGEX);\r\n        cpus = cpuInfo.listFiles(new FilenameFilter() {\r\n\r\n            @Override\r\n            public boolean accept(File file, String s) {\r\n                return cpuNamePattern.matcher(s).matches();\r\n            }\r\n        });\r\n    } catch (Throwable t) {\r\n        if (Log.isLoggable(TAG, Log.ERROR)) {\r\n            Log.e(TAG, \"Failed to calculate accurate cpu count\", t);\r\n        }\r\n    } finally {\r\n        StrictMode.setThreadPolicy(originalPolicy);\r\n    }\r\n    return Math.max(1, cpus != null ? cpus.length : 0);\r\n}","pathname":"D:\\Documents\\PA_Research\\DocModularity_Study\\glide\\library\/src\/main\/java\/com\/bumptech\/glide\/load\/engine\/executor\/RuntimeCompat.java"}
'6cee6d2c1'