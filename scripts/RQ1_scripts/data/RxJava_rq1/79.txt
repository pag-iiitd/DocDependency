{"randomdocline":"This type of scheduler is less sensitive to leaking {@link io.reactivex.rxjava3.core.Scheduler.Worker} instances, although","signature":"public static Scheduler computation()","doc":"Returns a default, shared {@link Scheduler} instance intended for computational work.\r\n<p>\r\nThis can be used for event-loops, processing callbacks and other computational work.\r\n<p>\r\nIt is not recommended to perform blocking, IO-bound work on this scheduler. Use {@link #io()} instead.\r\n<p>\r\nThe default instance has a backing pool of single-threaded {@link ScheduledExecutorService} instances equal to\r\nthe number of available processors ({@link java.lang.Runtime#availableProcessors()}) to the Java VM.\r\n<p>\r\nUnhandled errors will be delivered to the scheduler Thread's {@link java.lang.Thread.UncaughtExceptionHandler}.\r\n<p>\r\nThis type of scheduler is less sensitive to leaking {@link io.reactivex.rxjava3.core.Scheduler.Worker} instances, although\r\nnot disposing a worker that has timed\/delayed tasks not cancelled by other means may leak resources and\/or\r\nexecute those tasks \"unexpectedly\".\r\n<p>\r\nIf the {@link RxJavaPlugins#setFailOnNonBlockingScheduler(boolean)} is set to true, attempting to execute\r\noperators that block while running on this scheduler will throw an {@link IllegalStateException}.\r\n<p>\r\nYou can control certain properties of this standard scheduler via system properties that have to be set\r\nbefore the {@link Schedulers} class is referenced in your code.\r\n<p><strong>Supported system properties ({@code System.getProperty()}):<\/strong>\r\n<ul>\r\n<li>{@code rx3.computation-threads} (int): sets the number of threads in the {@code computation()} Scheduler, default is the number of available CPUs<\/li>\r\n<li>{@code rx3.computation-priority} (int): sets the thread priority of the {@code computation()} Scheduler, default is {@link Thread#NORM_PRIORITY}<\/li>\r\n<\/ul>\r\n<p>\r\nThe default value of this scheduler can be overridden at initialization time via the\r\n{@link RxJavaPlugins#setInitComputationSchedulerHandler(io.reactivex.rxjava3.functions.Function)} plugin method.\r\nNote that due to possible initialization cycles, using any of the other scheduler-returning methods will\r\nresult in a {@code NullPointerException}.\r\nOnce the {@link Schedulers} class has been initialized, you can override the returned {@link Scheduler} instance\r\nvia the {@link RxJavaPlugins#setComputationSchedulerHandler(io.reactivex.rxjava3.functions.Function)} method.\r\n<p>\r\nIt is possible to create a fresh instance of this scheduler with a custom ThreadFactory, via the\r\n{@link RxJavaPlugins#createComputationScheduler(ThreadFactory)} method. Note that such custom\r\ninstances require a manual call to {@link Scheduler#shutdown()} to allow the JVM to exit or the\r\n(J2EE) container to unload properly.\r\n<p>Operators on the base reactive classes that use this scheduler are marked with the\r\n&#64;{@link io.reactivex.rxjava3.annotations.SchedulerSupport SchedulerSupport}({@link io.reactivex.rxjava3.annotations.SchedulerSupport#COMPUTATION COMPUTATION})\r\nannotation.\r\n\r\n@return a {@link Scheduler} meant for computation-bound work\r\n","source":"{\r\n    return RxJavaPlugins.onComputationScheduler(COMPUTATION);\r\n}","pathname":"D:\\Documents\\PA_Research\\DocModularity_Study\\RxJava\\src\/main\/java\/io\/reactivex\/rxjava3\/schedulers\/Schedulers.java"}
'a1693ecc9'