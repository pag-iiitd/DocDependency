{"randomdocline":"Offer two elements at the same time.","signature":"public boolean offer(T first, T second)","doc":"Offer two elements at the same time.\r\n<p>Don't use the regular offer() with this at all!\r\n\r\n@param first the first value, not null\r\n@param second the second value, not null\r\n@return true if the queue accepted the two new values\r\n","source":"{\r\n    final AtomicReferenceArray<Object> buffer = producerBuffer;\r\n    final long p = lvProducerIndex();\r\n    final int m = producerMask;\r\n    int pi = calcWrappedOffset(p + 2, m);\r\n    if (null == lvElement(buffer, pi)) {\r\n        pi = calcWrappedOffset(p, m);\r\n        soElement(buffer, pi + 1, second);\r\n        soElement(buffer, pi, first);\r\n        soProducerIndex(p + 2);\r\n    } else {\r\n        final int capacity = buffer.length();\r\n        final AtomicReferenceArray<Object> newBuffer = new AtomicReferenceArray<>(capacity);\r\n        producerBuffer = newBuffer;\r\n        pi = calcWrappedOffset(p, m);\r\n        \/\/ StoreStore\r\n        soElement(newBuffer, pi + 1, second);\r\n        soElement(newBuffer, pi, first);\r\n        soNext(buffer, newBuffer);\r\n        \/\/ new buffer is visible after element is\r\n        soElement(buffer, pi, HAS_NEXT);\r\n        \/\/ this ensures correctness on 32bit platforms\r\n        soProducerIndex(p + 2);\r\n    }\r\n    return true;\r\n}","pathname":"D:\\Documents\\PA_Research\\DocModularity_Study\\RxJava\\src\/main\/java\/io\/reactivex\/rxjava3\/internal\/queue\/SpscLinkedArrayQueue.java"}
'a1693ecc9'
'802b9169a'