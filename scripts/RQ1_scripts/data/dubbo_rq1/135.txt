{"randomdocline":"<li> float, double -> float, double","signature":"public static Object compatibleTypeConvert(Object value, Class<?> type)","doc":"Compatible type convert. Null value is allowed to pass in. If no conversion is needed, then the original value\r\nwill be returned.\r\n<p>\r\nSupported compatible type conversions include (primary types and corresponding wrappers are not listed):\r\n<ul>\r\n<li> String -> char, enum, Date\r\n<li> byte, short, int, long -> byte, short, int, long\r\n<li> float, double -> float, double\r\n<\/ul>\r\n","source":"{\r\n    if (value == null || type == null || type.isAssignableFrom(value.getClass())) {\r\n        return value;\r\n    }\r\n    if (value instanceof String) {\r\n        String string = (String) value;\r\n        if (char.class.equals(type) || Character.class.equals(type)) {\r\n            if (string.length() != 1) {\r\n                throw new IllegalArgumentException(String.format(\"CAN NOT convert String(%s) to char!\" + \" when convert String to char, the String MUST only 1 char.\", string));\r\n            }\r\n            return string.charAt(0);\r\n        }\r\n        if (type.isEnum()) {\r\n            return Enum.valueOf((Class<Enum>) type, string);\r\n        }\r\n        if (type == BigInteger.class) {\r\n            return new BigInteger(string);\r\n        }\r\n        if (type == BigDecimal.class) {\r\n            return new BigDecimal(string);\r\n        }\r\n        if (type == Short.class || type == short.class) {\r\n            return new Short(string);\r\n        }\r\n        if (type == Integer.class || type == int.class) {\r\n            return new Integer(string);\r\n        }\r\n        if (type == Long.class || type == long.class) {\r\n            return new Long(string);\r\n        }\r\n        if (type == Double.class || type == double.class) {\r\n            return new Double(string);\r\n        }\r\n        if (type == Float.class || type == float.class) {\r\n            return new Float(string);\r\n        }\r\n        if (type == Byte.class || type == byte.class) {\r\n            return new Byte(string);\r\n        }\r\n        if (type == Boolean.class || type == boolean.class) {\r\n            return Boolean.valueOf(string);\r\n        }\r\n        if (type == Date.class || type == java.sql.Date.class || type == java.sql.Timestamp.class || type == java.sql.Time.class) {\r\n            try {\r\n                Date date = new SimpleDateFormat(DATE_FORMAT).parse(string);\r\n                if (type == java.sql.Date.class) {\r\n                    return new java.sql.Date(date.getTime());\r\n                }\r\n                if (type == java.sql.Timestamp.class) {\r\n                    return new java.sql.Timestamp(date.getTime());\r\n                }\r\n                if (type == java.sql.Time.class) {\r\n                    return new java.sql.Time(date.getTime());\r\n                }\r\n                return date;\r\n            } catch (ParseException e) {\r\n                throw new IllegalStateException(\"Failed to parse date \" + value + \" by format \" + DATE_FORMAT + \", cause: \" + e.getMessage(), e);\r\n            }\r\n        }\r\n        if (type == java.time.LocalDateTime.class || type == java.time.LocalDate.class || type == java.time.LocalTime.class) {\r\n            LocalDateTime localDateTime = LocalDateTime.parse(string);\r\n            if (type == java.time.LocalDate.class) {\r\n                return localDateTime.toLocalDate();\r\n            }\r\n            if (type == java.time.LocalTime.class) {\r\n                return localDateTime.toLocalTime();\r\n            }\r\n            return localDateTime;\r\n        }\r\n        if (type == Class.class) {\r\n            try {\r\n                return ReflectUtils.name2class(string);\r\n            } catch (ClassNotFoundException e) {\r\n                throw new RuntimeException(e.getMessage(), e);\r\n            }\r\n        }\r\n        if (char[].class.equals(type)) {\r\n            \/\/ Process string to char array for generic invoke\r\n            \/\/ See\r\n            \/\/ - https:\/\/github.com\/apache\/dubbo\/issues\/2003\r\n            int len = string.length();\r\n            char[] chars = new char[len];\r\n            string.getChars(0, len, chars, 0);\r\n            return chars;\r\n        }\r\n    }\r\n    if (value instanceof Number) {\r\n        Number number = (Number) value;\r\n        if (type == byte.class || type == Byte.class) {\r\n            return number.byteValue();\r\n        }\r\n        if (type == short.class || type == Short.class) {\r\n            return number.shortValue();\r\n        }\r\n        if (type == int.class || type == Integer.class) {\r\n            return number.intValue();\r\n        }\r\n        if (type == long.class || type == Long.class) {\r\n            return number.longValue();\r\n        }\r\n        if (type == float.class || type == Float.class) {\r\n            return number.floatValue();\r\n        }\r\n        if (type == double.class || type == Double.class) {\r\n            return number.doubleValue();\r\n        }\r\n        if (type == BigInteger.class) {\r\n            return BigInteger.valueOf(number.longValue());\r\n        }\r\n        if (type == BigDecimal.class) {\r\n            return BigDecimal.valueOf(number.doubleValue());\r\n        }\r\n        if (type == Date.class) {\r\n            return new Date(number.longValue());\r\n        }\r\n        if (type == boolean.class || type == Boolean.class) {\r\n            return 0 != number.intValue();\r\n        }\r\n    }\r\n    if (value instanceof Collection) {\r\n        Collection collection = (Collection) value;\r\n        if (type.isArray()) {\r\n            int length = collection.size();\r\n            Object array = Array.newInstance(type.getComponentType(), length);\r\n            int i = 0;\r\n            for (Object item : collection) {\r\n                Array.set(array, i++, item);\r\n            }\r\n            return array;\r\n        }\r\n        if (!type.isInterface()) {\r\n            try {\r\n                Collection result = (Collection) type.newInstance();\r\n                result.addAll(collection);\r\n                return result;\r\n            } catch (Throwable ignored) {\r\n            }\r\n        }\r\n        if (type == List.class) {\r\n            return new ArrayList<Object>(collection);\r\n        }\r\n        if (type == Set.class) {\r\n            return new HashSet<Object>(collection);\r\n        }\r\n    }\r\n    if (value.getClass().isArray() && Collection.class.isAssignableFrom(type)) {\r\n        Collection collection;\r\n        if (!type.isInterface()) {\r\n            try {\r\n                collection = (Collection) type.newInstance();\r\n            } catch (Throwable e) {\r\n                collection = new ArrayList<Object>();\r\n            }\r\n        } else if (type == Set.class) {\r\n            collection = new HashSet<Object>();\r\n        } else {\r\n            collection = new ArrayList<Object>();\r\n        }\r\n        int length = Array.getLength(value);\r\n        for (int i = 0; i < length; i++) {\r\n            collection.add(Array.get(value, i));\r\n        }\r\n        return collection;\r\n    }\r\n    return value;\r\n}","pathname":"D:\\Documents\\PA_Research\\DocModularity_Study\\dubbo\\dubbo-common\/src\/main\/java\/org\/apache\/dubbo\/common\/utils\/CompatibleTypeUtils.java"}
'e92a55364'
'10052d468'