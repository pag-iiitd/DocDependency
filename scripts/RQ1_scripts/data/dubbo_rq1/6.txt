{"randomdocline":"Return MockInvoker","signature":"private List<Invoker<T>> selectMockInvoker(Invocation invocation)","doc":"Return MockInvoker\r\nContractï¼\u009A\r\ndirectory.list() will return a list of normal invokers if Constants.INVOCATION_NEED_MOCK is present in invocation, otherwise, a list of mock invokers will return.\r\nif directory.list() returns more than one mock invoker, only one of them will be used.\r\n\r\n@param invocation\r\n@return\r\n","source":"{\r\n    List<Invoker<T>> invokers = null;\r\n    \/\/ TODO generic invokerï¼\u009F\r\n    if (invocation instanceof RpcInvocation) {\r\n        \/\/ Note the implicit contract (although the description is added to the interface declaration, but extensibility is a problem. The practice placed in the attachment needs to be improved)\r\n        ((RpcInvocation) invocation).setAttachment(INVOCATION_NEED_MOCK, Boolean.TRUE.toString());\r\n        \/\/ directory will return a list of normal invokers if Constants.INVOCATION_NEED_MOCK is present in invocation, otherwise, a list of mock invokers will return.\r\n        try {\r\n            invokers = directory.list(invocation);\r\n        } catch (RpcException e) {\r\n            if (logger.isInfoEnabled()) {\r\n                logger.info(\"Exception when try to invoke mock. Get mock invokers error for service:\" + getUrl().getServiceInterface() + \", method:\" + invocation.getMethodName() + \", will construct a new mock with 'new MockInvoker()'.\", e);\r\n            }\r\n        }\r\n    }\r\n    return invokers;\r\n}","pathname":"D:\\Documents\\PA_Research\\DocModularity_Study\\dubbo\\dubbo-cluster\/src\/main\/java\/org\/apache\/dubbo\/rpc\/cluster\/support\/wrapper\/MockClusterInvoker.java"}