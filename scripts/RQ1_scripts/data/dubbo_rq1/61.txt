{"randomdocline":"@return Proxy instance.","signature":"public static Proxy getProxy(ClassLoader cl, Class<?>... ics)","doc":"Get proxy.\r\n\r\n@param cl class loader.\r\n@param ics interface class array.\r\n@return Proxy instance.\r\n","source":"{\r\n    if (ics.length > MAX_PROXY_COUNT) {\r\n        throw new IllegalArgumentException(\"interface limit exceeded\");\r\n    }\r\n    StringBuilder sb = new StringBuilder();\r\n    for (int i = 0; i < ics.length; i++) {\r\n        String itf = ics[i].getName();\r\n        if (!ics[i].isInterface()) {\r\n            throw new RuntimeException(itf + \" is not a interface.\");\r\n        }\r\n        Class<?> tmp = null;\r\n        try {\r\n            tmp = Class.forName(itf, false, cl);\r\n        } catch (ClassNotFoundException e) {\r\n        }\r\n        if (tmp != ics[i]) {\r\n            throw new IllegalArgumentException(ics[i] + \" is not visible from class loader\");\r\n        }\r\n        sb.append(itf).append(';');\r\n    }\r\n    \/\/ use interface class name list as key.\r\n    String key = sb.toString();\r\n    \/\/ get cache by class loader.\r\n    final Map<String, Object> cache;\r\n    synchronized (PROXY_CACHE_MAP) {\r\n        cache = PROXY_CACHE_MAP.computeIfAbsent(cl, k -> new HashMap<>());\r\n    }\r\n    Proxy proxy = null;\r\n    synchronized (cache) {\r\n        do {\r\n            Object value = cache.get(key);\r\n            if (value instanceof Reference<?>) {\r\n                proxy = (Proxy) ((Reference<?>) value).get();\r\n                if (proxy != null) {\r\n                    return proxy;\r\n                }\r\n            }\r\n            if (value == PENDING_GENERATION_MARKER) {\r\n                try {\r\n                    cache.wait();\r\n                } catch (InterruptedException e) {\r\n                }\r\n            } else {\r\n                cache.put(key, PENDING_GENERATION_MARKER);\r\n                break;\r\n            }\r\n        } while (true);\r\n    }\r\n    long id = PROXY_CLASS_COUNTER.getAndIncrement();\r\n    String pkg = null;\r\n    ClassGenerator ccp = null, ccm = null;\r\n    try {\r\n        ccp = ClassGenerator.newInstance(cl);\r\n        Set<String> worked = new HashSet<>();\r\n        List<Method> methods = new ArrayList<>();\r\n        for (int i = 0; i < ics.length; i++) {\r\n            if (!Modifier.isPublic(ics[i].getModifiers())) {\r\n                String npkg = ics[i].getPackage().getName();\r\n                if (pkg == null) {\r\n                    pkg = npkg;\r\n                } else {\r\n                    if (!pkg.equals(npkg)) {\r\n                        throw new IllegalArgumentException(\"non-public interfaces from different packages\");\r\n                    }\r\n                }\r\n            }\r\n            ccp.addInterface(ics[i]);\r\n            for (Method method : ics[i].getMethods()) {\r\n                String desc = ReflectUtils.getDesc(method);\r\n                if (worked.contains(desc) || Modifier.isStatic(method.getModifiers())) {\r\n                    continue;\r\n                }\r\n                if (ics[i].isInterface() && Modifier.isStatic(method.getModifiers())) {\r\n                    continue;\r\n                }\r\n                worked.add(desc);\r\n                int ix = methods.size();\r\n                Class<?> rt = method.getReturnType();\r\n                Class<?>[] pts = method.getParameterTypes();\r\n                StringBuilder code = new StringBuilder(\"Object[] args = new Object[\").append(pts.length).append(\"];\");\r\n                for (int j = 0; j < pts.length; j++) {\r\n                    code.append(\" args[\").append(j).append(\"] = ($w)$\").append(j + 1).append(\";\");\r\n                }\r\n                code.append(\" Object ret = handler.invoke(this, methods[\").append(ix).append(\"], args);\");\r\n                if (!Void.TYPE.equals(rt)) {\r\n                    code.append(\" return \").append(asArgument(rt, \"ret\")).append(\";\");\r\n                }\r\n                methods.add(method);\r\n                ccp.addMethod(method.getName(), method.getModifiers(), rt, pts, method.getExceptionTypes(), code.toString());\r\n            }\r\n        }\r\n        if (pkg == null) {\r\n            pkg = PACKAGE_NAME;\r\n        }\r\n        \/\/ create ProxyInstance class.\r\n        String pcn = pkg + \".proxy\" + id;\r\n        ccp.setClassName(pcn);\r\n        ccp.addField(\"public static java.lang.reflect.Method[] methods;\");\r\n        ccp.addField(\"private \" + InvocationHandler.class.getName() + \" handler;\");\r\n        ccp.addConstructor(Modifier.PUBLIC, new Class<?>[] { InvocationHandler.class }, new Class<?>[0], \"handler=$1;\");\r\n        ccp.addDefaultConstructor();\r\n        Class<?> clazz = ccp.toClass();\r\n        clazz.getField(\"methods\").set(null, methods.toArray(new Method[0]));\r\n        \/\/ create Proxy class.\r\n        String fcn = Proxy.class.getName() + id;\r\n        ccm = ClassGenerator.newInstance(cl);\r\n        ccm.setClassName(fcn);\r\n        ccm.addDefaultConstructor();\r\n        ccm.setSuperClass(Proxy.class);\r\n        ccm.addMethod(\"public Object newInstance(\" + InvocationHandler.class.getName() + \" h){ return new \" + pcn + \"($1); }\");\r\n        Class<?> pc = ccm.toClass();\r\n        proxy = (Proxy) pc.newInstance();\r\n    } catch (RuntimeException e) {\r\n        throw e;\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e.getMessage(), e);\r\n    } finally {\r\n        \/\/ release ClassGenerator\r\n        if (ccp != null) {\r\n            ccp.release();\r\n        }\r\n        if (ccm != null) {\r\n            ccm.release();\r\n        }\r\n        synchronized (cache) {\r\n            if (proxy == null) {\r\n                cache.remove(key);\r\n            } else {\r\n                cache.put(key, new WeakReference<Proxy>(proxy));\r\n            }\r\n            cache.notifyAll();\r\n        }\r\n    }\r\n    return proxy;\r\n}","pathname":"D:\\Documents\\PA_Research\\DocModularity_Study\\dubbo\\dubbo-common\/src\/main\/java\/org\/apache\/dubbo\/common\/bytecode\/Proxy.java"}